`#!/usr/bin/env node`

const
  fs = require('fs')
  net = require('net')
  assert = require('assert')
  json_socket = require('./json_socket')
const DEFAULT_PIDFILE = 'naught.json'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      obj[arg.substring(2)] = argv.shift()
    else
      return arg
  null

!function readPids (pidfile, cb)
  fs.readFile pidfile, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.error "server not running"
      process.exit(1)
      return
    assert.ifError err
    try
      pids = JSON.parse(data)
    catch
      console.error "Invalid pidfile: #{pidfile}"
      process.exit(1)
    cb(pids)

function getDaemonMessages (socket_path, cbs)
  socket = net.connect socket_path, cbs.ready
  json_socket.listen(socket, cbs.event)
  socket

!function printUsage
  for name, cmd in cmds
    console.error "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  fs.stat options.pidfile, !(err, stats) ->
    unless err?code is \ENOENT
      console.error("pidfile #{options.pidfile} already exists.")
      console.error("Stop the old server before starting a new one.")
      return
    child = spawn(process.execPath, [
      path.join(__dirname, "daemon.js"),
      options.'worker-count',
      options.pidfile,
      options.log,
      options.stderr,
      options.stdout,
      options.tmp,
      script,
    ].concat(argv), {
      env: process.env
      stdio: \inherit
      detached: true
      cwd: options.cwd
    })
    child.unref()


!function stopScript (options, pidfile)
  readPids pidfile, !(pids) ->
    try
      process.kill(pids.master, 'SIGTERM')
    catch e
      if e.code is \ESRCH
        console.error("No process killed with pid #{pids.master}.")
        console.error("`rm #{pidfile}` manually after ensuring your server is not already running.")
      else
        throw e

!function printDaemonMsg (msg)
  console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}, dying: #{msg.dying_count}"

!function deploy (options, pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !->
        process.once \SIGINT, !->
          console.error "aborting deploy"
          json_socket.send(socket, \DeployAbort)
        json_socket.send(socket, \Deploy)
      event: !(msg) ->
        switch msg.event
          case \ErrorDeployInProgress
            console.error "Deploy already in progress. Things you can do:"
            console.error "1. monitor #{pids.log.naught}"
            console.error "2. abort the deploy. see `naught help deploy-abort`"
            process.exit(1)
          case \Ready
            console.error "done"
            process.exit(0)
          default
            printDaemonMsg msg

!function deployAbort (pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !-> json_socket.send(socket, \DeployAbort)
      event: !(msg) ->
        switch msg.event
          case \ErrorNoDeployInProgress
            console.error "no deploy in progress"
            process.exit(1)
          case \Ready
            console.error "deploy aborted"
            process.exit(0)
          default
            printDaemonMsg msg

!function displayStatus (pidfile)
  readPids pidfile, !(pids) ->
    console.log "#{pids.daemon} #{pids.master} #{pids.script}"

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd .
        --tmp /tmp
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
        'tmp': '/tmp'
      script = chompArgv(options, argv)
      if script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends SIGTERM to the process and waits for timeout, then
        sends SIGKILL if the process has not already exited.

        Available options and their defaults:

            --timeout 5
    """
    fn: (argv) ->
      options =
        timeout: '5'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = parseFloat(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  status:
    help: """
    naught status [pidfile]

        Displays whether a server is running or not.
        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      displayStatus(pidfile)
      true

  deploy:
    help: """
    naught deploy [options] [pidfile]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command.

        Naught spawns all the new workers and waits for them to all become
        online before killing a single old worker. This guarantees zero
        downtime if any of the new workers fail and provides the ability to
        cleanly abort the deployment if it hangs.

        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = options.timeout is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.error(cmd.help)
else
  printUsage()
